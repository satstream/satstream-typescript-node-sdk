/**
 * Satstream API
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.satstream.io/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class BigInt {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return BigInt.attributeTypeMap;
    }
}

export class BlocksErrorResponse {
    'code'?: number;
    'data'?: any;
    'msg'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "msg",
            "baseName": "msg",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BlocksErrorResponse.attributeTypeMap;
    }
}

export class InlineResponse200 {
    'data'?: ResponsesGetAddressBalance;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "ResponsesGetAddressBalance"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    'data'?: ResponsesGetAddressTimeframeBalance;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "ResponsesGetAddressTimeframeBalance"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class InlineResponse20010 {
    'data'?: ResponsesTxInfo;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "ResponsesTxInfo"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20010.attributeTypeMap;
    }
}

export class InlineResponse2002 {
    'data'?: Array<ResponsesGetAddressRunesBalanceListItem>;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ResponsesGetAddressRunesBalanceListItem>"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002.attributeTypeMap;
    }
}

export class InlineResponse2003 {
    'data'?: ResponsesGetAddressRuneBalance;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "ResponsesGetAddressRuneBalance"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2003.attributeTypeMap;
    }
}

export class InlineResponse2004 {
    'data'?: Array<ResponsesGetAddressNonInscriptionUTXOData>;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ResponsesGetAddressNonInscriptionUTXOData>"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2004.attributeTypeMap;
    }
}

export class InlineResponse2005 {
    'data'?: number;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "number"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2005.attributeTypeMap;
    }
}

export class InlineResponse2006 {
    'data'?: RpcBlock;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "RpcBlock"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2006.attributeTypeMap;
    }
}

export class InlineResponse2007 {
    'data'?: { [key: string]: number; };
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2007.attributeTypeMap;
    }
}

export class InlineResponse2008 {
    'data'?: RpcBtcTx;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "RpcBtcTx"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008.attributeTypeMap;
    }
}

export class InlineResponse2009 {
    'data'?: ResponsesSendRawTransaction;
    'responsesBaseResponse'?: ResponsesBaseResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "ResponsesSendRawTransaction"
        },
        {
            "name": "responsesBaseResponse",
            "baseName": "responses.BaseResponse",
            "type": "ResponsesBaseResponse"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2009.attributeTypeMap;
    }
}

export class ResponsesBaseResponse {
    'code'?: number;
    'data'?: any;
    'msg'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "msg",
            "baseName": "msg",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesBaseResponse.attributeTypeMap;
    }
}

export class ResponsesBlockRange {
    'end'?: number;
    'start'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "end",
            "baseName": "end",
            "type": "number"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesBlockRange.attributeTypeMap;
    }
}

export class ResponsesGetAddressBalance {
    'address'?: string;
    'balance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressBalance.attributeTypeMap;
    }
}

export class ResponsesGetAddressNonInscriptionUTXOData {
    'cursor'?: number;
    'total'?: number;
    'totalConfirmed'?: number;
    'totalRunes'?: number;
    'totalUnconfirmed'?: number;
    'totalUnconfirmedSpend'?: number;
    'utxo'?: Array<ResponsesNonInscriptionUTXO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "totalConfirmed",
            "baseName": "totalConfirmed",
            "type": "number"
        },
        {
            "name": "totalRunes",
            "baseName": "totalRunes",
            "type": "number"
        },
        {
            "name": "totalUnconfirmed",
            "baseName": "totalUnconfirmed",
            "type": "number"
        },
        {
            "name": "totalUnconfirmedSpend",
            "baseName": "totalUnconfirmedSpend",
            "type": "number"
        },
        {
            "name": "utxo",
            "baseName": "utxo",
            "type": "Array<ResponsesNonInscriptionUTXO>"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressNonInscriptionUTXOData.attributeTypeMap;
    }
}

export class ResponsesGetAddressRuneBalance {
    'amount'?: string;
    'divisibility'?: number;
    'rune'?: string;
    'runeid'?: string;
    'spacedAmount'?: string;
    'spacedRune'?: string;
    'symbol'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "divisibility",
            "baseName": "divisibility",
            "type": "number"
        },
        {
            "name": "rune",
            "baseName": "rune",
            "type": "string"
        },
        {
            "name": "runeid",
            "baseName": "runeid",
            "type": "string"
        },
        {
            "name": "spacedAmount",
            "baseName": "spacedAmount",
            "type": "string"
        },
        {
            "name": "spacedRune",
            "baseName": "spacedRune",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressRuneBalance.attributeTypeMap;
    }
}

export class ResponsesGetAddressRunesBalanceListItem {
    'amount'?: string;
    'parsedAmount'?: string;
    'runeId'?: string;
    'spacedRune'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "parsedAmount",
            "baseName": "parsedAmount",
            "type": "string"
        },
        {
            "name": "runeId",
            "baseName": "rune_id",
            "type": "string"
        },
        {
            "name": "spacedRune",
            "baseName": "spacedRune",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressRunesBalanceListItem.attributeTypeMap;
    }
}

export class ResponsesGetAddressTimeframeBalance {
    'items'?: Array<ResponsesGetAddressTimeframeBalanceItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ResponsesGetAddressTimeframeBalanceItem>"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressTimeframeBalance.attributeTypeMap;
    }
}

export class ResponsesGetAddressTimeframeBalanceItem {
    'balance'?: number;
    'blockRange'?: ResponsesGetAddressTimeframeBalanceItemBlockRange;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "blockRange",
            "baseName": "blockRange",
            "type": "ResponsesGetAddressTimeframeBalanceItemBlockRange"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressTimeframeBalanceItem.attributeTypeMap;
    }
}

/**
* Time       time.Time  `json:\"time\"`
*/
export class ResponsesGetAddressTimeframeBalanceItemBlockRange {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ResponsesGetAddressTimeframeBalanceItemBlockRange.attributeTypeMap;
    }
}

export class ResponsesNonInscriptionUTXO {
    'address'?: string;
    'codeType'?: number;
    'height'?: number;
    'idx'?: number;
    'isOpInRBF'?: boolean;
    'isSpent'?: boolean;
    'satoshi'?: BigInt;
    'scriptPk'?: string;
    'scriptType'?: string;
    'txid'?: string;
    'vout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "codeType",
            "baseName": "codeType",
            "type": "number"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "idx",
            "baseName": "idx",
            "type": "number"
        },
        {
            "name": "isOpInRBF",
            "baseName": "isOpInRBF",
            "type": "boolean"
        },
        {
            "name": "isSpent",
            "baseName": "isSpent",
            "type": "boolean"
        },
        {
            "name": "satoshi",
            "baseName": "satoshi",
            "type": "BigInt"
        },
        {
            "name": "scriptPk",
            "baseName": "scriptPk",
            "type": "string"
        },
        {
            "name": "scriptType",
            "baseName": "scriptType",
            "type": "string"
        },
        {
            "name": "txid",
            "baseName": "txid",
            "type": "string"
        },
        {
            "name": "vout",
            "baseName": "vout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesNonInscriptionUTXO.attributeTypeMap;
    }
}

export class ResponsesSendRawTransaction {
    'txHash'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "txHash",
            "baseName": "tx_hash",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesSendRawTransaction.attributeTypeMap;
    }
}

export class ResponsesTxInfo {
    'blkid'?: string;
    'height'?: number;
    'idx'?: number;
    'inSatoshi'?: BigInt;
    'locktime'?: number;
    'nIn'?: number;
    'nInInscription'?: number;
    'nLostInscription'?: number;
    'nNewInscription'?: number;
    'nOut'?: number;
    'nOutInscription'?: number;
    'outSatoshi'?: BigInt;
    'size'?: number;
    'txid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blkid",
            "baseName": "blkid",
            "type": "string"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "idx",
            "baseName": "idx",
            "type": "number"
        },
        {
            "name": "inSatoshi",
            "baseName": "inSatoshi",
            "type": "BigInt"
        },
        {
            "name": "locktime",
            "baseName": "locktime",
            "type": "number"
        },
        {
            "name": "nIn",
            "baseName": "nIn",
            "type": "number"
        },
        {
            "name": "nInInscription",
            "baseName": "nInInscription",
            "type": "number"
        },
        {
            "name": "nLostInscription",
            "baseName": "nLostInscription",
            "type": "number"
        },
        {
            "name": "nNewInscription",
            "baseName": "nNewInscription",
            "type": "number"
        },
        {
            "name": "nOut",
            "baseName": "nOut",
            "type": "number"
        },
        {
            "name": "nOutInscription",
            "baseName": "nOutInscription",
            "type": "number"
        },
        {
            "name": "outSatoshi",
            "baseName": "outSatoshi",
            "type": "BigInt"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "txid",
            "baseName": "txid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResponsesTxInfo.attributeTypeMap;
    }
}

export class RpcBlock {
    'bits'?: string;
    'chainwork'?: string;
    'confirmations'?: number;
    'difficulty'?: number;
    'hash'?: string;
    'height'?: number;
    'mediantime'?: number;
    'merkleroot'?: string;
    'nTx'?: number;
    'nonce'?: number;
    'previousblockhash'?: string;
    'size'?: number;
    'strippedSize'?: number;
    'time'?: number;
    /**
    * Txns will be stored in a separate collection in the DB
    */
    'tx'?: Array<RpcBtcTx>;
    'version'?: number;
    'versionHex'?: string;
    'weight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bits",
            "baseName": "bits",
            "type": "string"
        },
        {
            "name": "chainwork",
            "baseName": "chainwork",
            "type": "string"
        },
        {
            "name": "confirmations",
            "baseName": "confirmations",
            "type": "number"
        },
        {
            "name": "difficulty",
            "baseName": "difficulty",
            "type": "number"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "mediantime",
            "baseName": "mediantime",
            "type": "number"
        },
        {
            "name": "merkleroot",
            "baseName": "merkleroot",
            "type": "string"
        },
        {
            "name": "nTx",
            "baseName": "nTx",
            "type": "number"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "number"
        },
        {
            "name": "previousblockhash",
            "baseName": "previousblockhash",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "strippedSize",
            "baseName": "strippedSize",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "tx",
            "baseName": "tx",
            "type": "Array<RpcBtcTx>"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "versionHex",
            "baseName": "versionHex",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RpcBlock.attributeTypeMap;
    }
}

export class RpcBtcTx {
    'blockheight'?: number;
    'fee'?: number;
    'hash'?: string;
    'hex'?: string;
    'index'?: number;
    'locktime'?: number;
    'size'?: number;
    'txid'?: string;
    'version'?: number;
    /**
    * Vin will be stored in a separate collection in the DB
    */
    'vin'?: Array<RpcVin>;
    /**
    * Vout will be stored in a separate collection in the DB
    */
    'vout'?: Array<RpcVout>;
    'vsize'?: number;
    'weight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blockheight",
            "baseName": "blockheight",
            "type": "number"
        },
        {
            "name": "fee",
            "baseName": "fee",
            "type": "number"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "hex",
            "baseName": "hex",
            "type": "string"
        },
        {
            "name": "index",
            "baseName": "index",
            "type": "number"
        },
        {
            "name": "locktime",
            "baseName": "locktime",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "txid",
            "baseName": "txid",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "vin",
            "baseName": "vin",
            "type": "Array<RpcVin>"
        },
        {
            "name": "vout",
            "baseName": "vout",
            "type": "Array<RpcVout>"
        },
        {
            "name": "vsize",
            "baseName": "vsize",
            "type": "number"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RpcBtcTx.attributeTypeMap;
    }
}

export class RpcPrevOut {
    'height'?: number;
    'n'?: number;
    /**
    * * The populated field is used to determine if the prevout has been populated from our code or automatically by the RPC on fetch
    */
    'populated'?: boolean;
    'runeHoldings'?: Array<RpcUtxoRune>;
    'scriptPubKey'?: RpcScriptPubKey;
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "n",
            "baseName": "n",
            "type": "number"
        },
        {
            "name": "populated",
            "baseName": "populated",
            "type": "boolean"
        },
        {
            "name": "runeHoldings",
            "baseName": "rune_holdings",
            "type": "Array<RpcUtxoRune>"
        },
        {
            "name": "scriptPubKey",
            "baseName": "scriptPubKey",
            "type": "RpcScriptPubKey"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RpcPrevOut.attributeTypeMap;
    }
}

export class RpcScriptPubKey {
    'address'?: string;
    'asm'?: string;
    'desc'?: string;
    'hex'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "asm",
            "baseName": "asm",
            "type": "string"
        },
        {
            "name": "desc",
            "baseName": "desc",
            "type": "string"
        },
        {
            "name": "hex",
            "baseName": "hex",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RpcScriptPubKey.attributeTypeMap;
    }
}

export class RpcScriptSig {
    'asm'?: string;
    'hex'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "asm",
            "baseName": "asm",
            "type": "string"
        },
        {
            "name": "hex",
            "baseName": "hex",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RpcScriptSig.attributeTypeMap;
    }
}

export class RpcUtxoRune {
    'amount'?: BigInt;
    'runeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "BigInt"
        },
        {
            "name": "runeId",
            "baseName": "rune_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RpcUtxoRune.attributeTypeMap;
    }
}

export class RpcVin {
    'coinbase'?: string;
    'prevout'?: RpcPrevOut;
    'scriptSig'?: RpcScriptSig;
    'sequence'?: number;
    'txid'?: string;
    'txinwitness'?: Array<string>;
    'vout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "coinbase",
            "baseName": "coinbase",
            "type": "string"
        },
        {
            "name": "prevout",
            "baseName": "prevout",
            "type": "RpcPrevOut"
        },
        {
            "name": "scriptSig",
            "baseName": "scriptSig",
            "type": "RpcScriptSig"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "number"
        },
        {
            "name": "txid",
            "baseName": "txid",
            "type": "string"
        },
        {
            "name": "txinwitness",
            "baseName": "txinwitness",
            "type": "Array<string>"
        },
        {
            "name": "vout",
            "baseName": "vout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RpcVin.attributeTypeMap;
    }
}

export class RpcVout {
    'n'?: number;
    'runeHoldings'?: Array<RpcUtxoRune>;
    'scriptPubKey'?: RpcScriptPubKey;
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "n",
            "baseName": "n",
            "type": "number"
        },
        {
            "name": "runeHoldings",
            "baseName": "rune_holdings",
            "type": "Array<RpcUtxoRune>"
        },
        {
            "name": "scriptPubKey",
            "baseName": "scriptPubKey",
            "type": "RpcScriptPubKey"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RpcVout.attributeTypeMap;
    }
}

export class SsApiServerApiRunesResponsesErrorResponse {
    'code'?: number;
    'data'?: any;
    'msg'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "msg",
            "baseName": "msg",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SsApiServerApiRunesResponsesErrorResponse.attributeTypeMap;
    }
}

export class SsApiServerApiTransactionsResponsesErrorResponse {
    'code'?: number;
    'data'?: any;
    'msg'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "msg",
            "baseName": "msg",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SsApiServerApiTransactionsResponsesErrorResponse.attributeTypeMap;
    }
}

/**
* Detailed information about a transaction
*/
export class StoreTransactionDocument {
    'address'?: string;
    'blockheight'?: number;
    'fee'?: number;
    'hash'?: string;
    'hex'?: string;
    'index'?: number;
    'locktime'?: number;
    'size'?: number;
    'txid'?: string;
    'version'?: number;
    'vsize'?: number;
    'weight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "blockheight",
            "baseName": "blockheight",
            "type": "number"
        },
        {
            "name": "fee",
            "baseName": "fee",
            "type": "number"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "hex",
            "baseName": "hex",
            "type": "string"
        },
        {
            "name": "index",
            "baseName": "index",
            "type": "number"
        },
        {
            "name": "locktime",
            "baseName": "locktime",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "txid",
            "baseName": "txid",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "vsize",
            "baseName": "vsize",
            "type": "number"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreTransactionDocument.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "BigInt": BigInt,
    "BlocksErrorResponse": BlocksErrorResponse,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "InlineResponse20010": InlineResponse20010,
    "InlineResponse2002": InlineResponse2002,
    "InlineResponse2003": InlineResponse2003,
    "InlineResponse2004": InlineResponse2004,
    "InlineResponse2005": InlineResponse2005,
    "InlineResponse2006": InlineResponse2006,
    "InlineResponse2007": InlineResponse2007,
    "InlineResponse2008": InlineResponse2008,
    "InlineResponse2009": InlineResponse2009,
    "ResponsesBaseResponse": ResponsesBaseResponse,
    "ResponsesBlockRange": ResponsesBlockRange,
    "ResponsesGetAddressBalance": ResponsesGetAddressBalance,
    "ResponsesGetAddressNonInscriptionUTXOData": ResponsesGetAddressNonInscriptionUTXOData,
    "ResponsesGetAddressRuneBalance": ResponsesGetAddressRuneBalance,
    "ResponsesGetAddressRunesBalanceListItem": ResponsesGetAddressRunesBalanceListItem,
    "ResponsesGetAddressTimeframeBalance": ResponsesGetAddressTimeframeBalance,
    "ResponsesGetAddressTimeframeBalanceItem": ResponsesGetAddressTimeframeBalanceItem,
    "ResponsesGetAddressTimeframeBalanceItemBlockRange": ResponsesGetAddressTimeframeBalanceItemBlockRange,
    "ResponsesNonInscriptionUTXO": ResponsesNonInscriptionUTXO,
    "ResponsesSendRawTransaction": ResponsesSendRawTransaction,
    "ResponsesTxInfo": ResponsesTxInfo,
    "RpcBlock": RpcBlock,
    "RpcBtcTx": RpcBtcTx,
    "RpcPrevOut": RpcPrevOut,
    "RpcScriptPubKey": RpcScriptPubKey,
    "RpcScriptSig": RpcScriptSig,
    "RpcUtxoRune": RpcUtxoRune,
    "RpcVin": RpcVin,
    "RpcVout": RpcVout,
    "SsApiServerApiRunesResponsesErrorResponse": SsApiServerApiRunesResponsesErrorResponse,
    "SsApiServerApiTransactionsResponsesErrorResponse": SsApiServerApiTransactionsResponsesErrorResponse,
    "StoreTransactionDocument": StoreTransactionDocument,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AddressesApiApiKeys {
    ApiKeyAuth,
}

export class AddressesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AddressesApiApiKeys, value: string) {
        (this.authentications as any)[AddressesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get the current balance of a Bitcoin address
     * @summary Get address balance
     * @param address Bitcoin address
     * @param {*} [options] Override http request options.
     */
    public addressesAddressBalanceGet (address: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/addresses/{address}/balance'
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressesAddressBalanceGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the balance of a Bitcoin address for a specific timeframe
     * @summary Get address timeframe balance
     * @param address Bitcoin address
     * @param start Start block height
     * @param end End block height
     * @param {*} [options] Override http request options.
     */
    public addressesAddressBalanceTimeframeGet (address: string, start: number, end: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/addresses/{address}/balance/timeframe'
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressesAddressBalanceTimeframeGet.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling addressesAddressBalanceTimeframeGet.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling addressesAddressBalanceTimeframeGet.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the balance of all runes for a Bitcoin address
     * @summary Get address runes balance list
     * @param address Bitcoin address
     * @param {*} [options] Override http request options.
     */
    public addressesAddressRunesGet (address: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/addresses/{address}/runes'
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressesAddressRunesGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2002");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the balance of a specific rune for a Bitcoin address
     * @summary Get address rune balance
     * @param address Bitcoin address
     * @param runeid Rune ID
     * @param {*} [options] Override http request options.
     */
    public addressesAddressRunesRuneidGet (address: string, runeid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/addresses/{address}/runes/{runeid}'
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)))
            .replace('{' + 'runeid' + '}', encodeURIComponent(String(runeid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressesAddressRunesRuneidGet.');
        }

        // verify required parameter 'runeid' is not null or undefined
        if (runeid === null || runeid === undefined) {
            throw new Error('Required parameter runeid was null or undefined when calling addressesAddressRunesRuneidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2003");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all non-inscription UTXOs for a Bitcoin address
     * @summary Get address non-inscription UTXOs
     * @param address Bitcoin address
     * @param {*} [options] Override http request options.
     */
    public addressesAddressUtxosGet (address: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }> {
        const localVarPath = this.basePath + '/addresses/{address}/utxos'
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressesAddressUtxosGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2004");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BlocksApiApiKeys {
    ApiKeyAuth,
}

export class BlocksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BlocksApiApiKeys, value: string) {
        (this.authentications as any)[BlocksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get the current block height of the Bitcoin blockchain
     * @summary Get current block height
     * @param {*} [options] Override http request options.
     */
    public blocksCurrentHeightGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }> {
        const localVarPath = this.basePath + '/blocks/current-height';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2005");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information about a specific block by its hash
     * @summary Get block by hash
     * @param hash Block hash
     * @param {*} [options] Override http request options.
     */
    public blocksHashHashGet (hash: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }> {
        const localVarPath = this.basePath + '/blocks/hash/{hash}'
            .replace('{' + 'hash' + '}', encodeURIComponent(String(hash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'hash' is not null or undefined
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling blocksHashHashGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2006");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information about a specific block by height
     * @summary Get block info
     * @param height Block height
     * @param {*} [options] Override http request options.
     */
    public blocksHeightGet (height: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }> {
        const localVarPath = this.basePath + '/blocks/{height}'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling blocksHeightGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2006");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get transactions for a specific block height
     * @summary Get block transactions
     * @param height Block height
     * @param {*} [options] Override http request options.
     */
    public blocksHeightTransactionsGet (height: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/blocks/{height}/transactions'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling blocksHeightTransactionsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeesApiApiKeys {
    ApiKeyAuth,
}

export class FeesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeesApiApiKeys, value: string) {
        (this.authentications as any)[FeesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get recommended fees for Bitcoin transactions
     * @summary Get recommended fees
     * @param {*} [options] Override http request options.
     */
    public feesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }> {
        const localVarPath = this.basePath + '/fees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2007");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MempoolApiApiKeys {
    ApiKeyAuth,
}

export class MempoolApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MempoolApiApiKeys, value: string) {
        (this.authentications as any)[MempoolApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get all mempool transactions for a specific address
     * @summary Get address mempool transactions
     * @param address Bitcoin address
     * @param {*} [options] Override http request options.
     */
    public mempoolAddressesAddressTransactionsGet (address: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/mempool/addresses/{address}/transactions'
            .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling mempoolAddressesAddressTransactionsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all transactions currently in the mempool
     * @summary Get mempool transactions
     * @param {*} [options] Override http request options.
     */
    public mempoolTransactionsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/mempool/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information about a specific transaction in the mempool
     * @summary Get mempool transaction info
     * @param txid Transaction ID
     * @param {*} [options] Override http request options.
     */
    public mempoolTransactionsTxidGet (txid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }> {
        const localVarPath = this.basePath + '/mempool/transactions/{txid}'
            .replace('{' + 'txid' + '}', encodeURIComponent(String(txid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'txid' is not null or undefined
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling mempoolTransactionsTxidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2008");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RunesApiApiKeys {
    ApiKeyAuth,
}

export class RunesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RunesApiApiKeys, value: string) {
        (this.authentications as any)[RunesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get information about all runes
     * @summary Get runes info list
     * @param {*} [options] Override http request options.
     */
    public runesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/runes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get detailed information about a specific rune
     * @summary Get rune info
     * @param runeId Rune ID
     * @param {*} [options] Override http request options.
     */
    public runesRuneIdGet (runeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/runes/{runeId}'
            .replace('{' + 'runeId' + '}', encodeURIComponent(String(runeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runeId' is not null or undefined
        if (runeId === null || runeId === undefined) {
            throw new Error('Required parameter runeId was null or undefined when calling runesRuneIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of addresses holding a specific rune
     * @summary Get rune holders
     * @param runeId Rune ID
     * @param {*} [options] Override http request options.
     */
    public runesRuneIdHoldersGet (runeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/runes/{runeId}/holders'
            .replace('{' + 'runeId' + '}', encodeURIComponent(String(runeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runeId' is not null or undefined
        if (runeId === null || runeId === undefined) {
            throw new Error('Required parameter runeId was null or undefined when calling runesRuneIdHoldersGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the current status of the runes system
     * @summary Get runes status
     * @param {*} [options] Override http request options.
     */
    public runesStatusGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/runes/status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionsApiApiKeys {
    ApiKeyAuth,
}

export class TransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get a transaction by its hash
     * @summary Get transaction
     * @param hash Transaction hash
     * @param {*} [options] Override http request options.
     */
    public indexerTxHashGet (hash: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }> {
        const localVarPath = this.basePath + '/indexer/tx/{hash}'
            .replace('{' + 'hash' + '}', encodeURIComponent(String(hash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'hash' is not null or undefined
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling indexerTxHashGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2008");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Broadcast a raw transaction to the Bitcoin network
     * @summary Broadcast transaction
     * @param transaction Raw transaction hex
     * @param {*} [options] Override http request options.
     */
    public transactionsBroadcastPost (transaction: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }> {
        const localVarPath = this.basePath + '/transactions/broadcast';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling transactionsBroadcastPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transaction, "string")
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2009");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get detailed information about a specific transaction
     * @summary Get transaction info
     * @param txid Transaction ID
     * @param {*} [options] Override http request options.
     */
    public transactionsTxidGet (txid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }> {
        const localVarPath = this.basePath + '/transactions/{txid}'
            .replace('{' + 'txid' + '}', encodeURIComponent(String(txid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'txid' is not null or undefined
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling transactionsTxidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20010");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the inputs of a specific transaction
     * @summary Get transaction inputs
     * @param txid Transaction ID
     * @param {*} [options] Override http request options.
     */
    public transactionsTxidInputsGet (txid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/transactions/{txid}/inputs'
            .replace('{' + 'txid' + '}', encodeURIComponent(String(txid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'txid' is not null or undefined
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling transactionsTxidInputsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
